// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v3.12.4
// source: chat.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "./google/protobuf/timestamp";

export const protobufPackage = "chat";

export interface GetTokenAndAddToChatRequest {
  userId: number;
  chatId: string;
}

export interface GetTokenAndAddToChatResponse {
  message: string;
  status: number;
}

export interface KickUserFromChatRequest {
  userId: number;
  participantId: number;
  chatId: string;
}

export interface KickUserFromChatResponse {
  message: string;
  status: number;
}

export interface PermissionToMemberRequest {
  userId: number;
  chatId: string;
  participantId: number;
}

export interface PermissionToMemberResponse {
  message: string;
  status: number;
}

export interface PermissionToAdminRequest {
  userId: number;
  chatId: string;
  participantId: number;
}

export interface PermissionToAdminResponse {
  message: string;
  status: number;
}

export interface CreateNewChatRequest {
  chatName: string;
  chatType: string;
  userId: number;
}

export interface CreateNewChatResponse {
  chatId: string;
}

export interface GetChatByIdRequest {
  chatId: string;
}

export interface GetChatByIdResponse {
  chatData?: Chat | undefined;
  notFound?: ErrorResponse | undefined;
}

export interface GetChatByChatNameRequest {
  chatName: string;
}

export interface GetChatByChatNameResponse {
  chatData: ChatIds[];
}

export interface ChatIds {
  chatId: string;
  chatName: string;
}

export interface UpdateChatByIdRequest {
  chatId: string;
  userId: number;
  chatName?: string | undefined;
  chatType?: string | undefined;
  description?: string | undefined;
}

export interface UpdateChatByIdResponse {
  response: GenericResponse | undefined;
}

export interface DeleteChatByIdRequest {
  userId: number;
  chatId: string;
}

export interface DeleteChatByIdResponse {
  response: DeleteChatByIdResponse_Response | undefined;
  info: DeleteChatByIdResponse_Info | undefined;
}

export interface DeleteChatByIdResponse_Response {
  message: string;
  status: number;
}

export interface DeleteChatByIdResponse_Info {
  chatId: string;
  data: number[];
}

export interface AddUserToChatRequest {
  chatId: string;
  participant: ChatParticipant | undefined;
}

export interface AddUserToChatResponse {
  response: GenericResponse | undefined;
}

export interface RemoveUserFromChatRequest {
  chatId: string;
  userId: number;
}

export interface RemoveUserFromChatResponse {
  response: GenericResponse | undefined;
}

export interface LoadToChatRequest {
  chatId: string;
  userId: number;
}

export interface LoadToChatResponse {
  response: GenericResponse | undefined;
}

export interface LeaveFromChatRequest {
  chatId: string;
  userId: number;
}

export interface LeaveFromChatResponse {
  response: GenericResponse | undefined;
}

export interface Chat {
  chatId: string;
  chatName: string;
  chatType: string;
  lastMessage: LastMessage | undefined;
  participants: ChatParticipant[];
  messages: Message[];
  createdAt: Date | undefined;
}

export interface LastMessage {
  messageId: string;
  senderId: number;
  preview: string;
}

export interface ChatParticipant {
  userId: number;
  /** 'owner', 'admin', 'member' */
  role: string;
}

export interface Message {
  messageId: string;
  senderId: number;
  text: string;
  timestamp: Date | undefined;
}

export interface ErrorResponse {
  message: string;
  status: number;
}

export interface GenericResponse {
  message: string;
  status: number;
}

function createBaseGetTokenAndAddToChatRequest(): GetTokenAndAddToChatRequest {
  return { userId: 0, chatId: "" };
}

export const GetTokenAndAddToChatRequest: MessageFns<GetTokenAndAddToChatRequest> = {
  encode(message: GetTokenAndAddToChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenAndAddToChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenAndAddToChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenAndAddToChatRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: GetTokenAndAddToChatRequest): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenAndAddToChatRequest>, I>>(base?: I): GetTokenAndAddToChatRequest {
    return GetTokenAndAddToChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenAndAddToChatRequest>, I>>(object: I): GetTokenAndAddToChatRequest {
    const message = createBaseGetTokenAndAddToChatRequest();
    message.userId = object.userId ?? 0;
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseGetTokenAndAddToChatResponse(): GetTokenAndAddToChatResponse {
  return { message: "", status: 0 };
}

export const GetTokenAndAddToChatResponse: MessageFns<GetTokenAndAddToChatResponse> = {
  encode(message: GetTokenAndAddToChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTokenAndAddToChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTokenAndAddToChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTokenAndAddToChatResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: GetTokenAndAddToChatResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTokenAndAddToChatResponse>, I>>(base?: I): GetTokenAndAddToChatResponse {
    return GetTokenAndAddToChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTokenAndAddToChatResponse>, I>>(object: I): GetTokenAndAddToChatResponse {
    const message = createBaseGetTokenAndAddToChatResponse();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseKickUserFromChatRequest(): KickUserFromChatRequest {
  return { userId: 0, participantId: 0, chatId: "" };
}

export const KickUserFromChatRequest: MessageFns<KickUserFromChatRequest> = {
  encode(message: KickUserFromChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.participantId !== 0) {
      writer.uint32(16).int32(message.participantId);
    }
    if (message.chatId !== "") {
      writer.uint32(26).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickUserFromChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickUserFromChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.participantId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KickUserFromChatRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      participantId: isSet(object.participantId) ? globalThis.Number(object.participantId) : 0,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: KickUserFromChatRequest): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.participantId !== 0) {
      obj.participantId = Math.round(message.participantId);
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KickUserFromChatRequest>, I>>(base?: I): KickUserFromChatRequest {
    return KickUserFromChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KickUserFromChatRequest>, I>>(object: I): KickUserFromChatRequest {
    const message = createBaseKickUserFromChatRequest();
    message.userId = object.userId ?? 0;
    message.participantId = object.participantId ?? 0;
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseKickUserFromChatResponse(): KickUserFromChatResponse {
  return { message: "", status: 0 };
}

export const KickUserFromChatResponse: MessageFns<KickUserFromChatResponse> = {
  encode(message: KickUserFromChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KickUserFromChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKickUserFromChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KickUserFromChatResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: KickUserFromChatResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KickUserFromChatResponse>, I>>(base?: I): KickUserFromChatResponse {
    return KickUserFromChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KickUserFromChatResponse>, I>>(object: I): KickUserFromChatResponse {
    const message = createBaseKickUserFromChatResponse();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBasePermissionToMemberRequest(): PermissionToMemberRequest {
  return { userId: 0, chatId: "", participantId: 0 };
}

export const PermissionToMemberRequest: MessageFns<PermissionToMemberRequest> = {
  encode(message: PermissionToMemberRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    if (message.participantId !== 0) {
      writer.uint32(24).int32(message.participantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionToMemberRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionToMemberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.participantId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionToMemberRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      participantId: isSet(object.participantId) ? globalThis.Number(object.participantId) : 0,
    };
  },

  toJSON(message: PermissionToMemberRequest): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.participantId !== 0) {
      obj.participantId = Math.round(message.participantId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionToMemberRequest>, I>>(base?: I): PermissionToMemberRequest {
    return PermissionToMemberRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionToMemberRequest>, I>>(object: I): PermissionToMemberRequest {
    const message = createBasePermissionToMemberRequest();
    message.userId = object.userId ?? 0;
    message.chatId = object.chatId ?? "";
    message.participantId = object.participantId ?? 0;
    return message;
  },
};

function createBasePermissionToMemberResponse(): PermissionToMemberResponse {
  return { message: "", status: 0 };
}

export const PermissionToMemberResponse: MessageFns<PermissionToMemberResponse> = {
  encode(message: PermissionToMemberResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionToMemberResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionToMemberResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionToMemberResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: PermissionToMemberResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionToMemberResponse>, I>>(base?: I): PermissionToMemberResponse {
    return PermissionToMemberResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionToMemberResponse>, I>>(object: I): PermissionToMemberResponse {
    const message = createBasePermissionToMemberResponse();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBasePermissionToAdminRequest(): PermissionToAdminRequest {
  return { userId: 0, chatId: "", participantId: 0 };
}

export const PermissionToAdminRequest: MessageFns<PermissionToAdminRequest> = {
  encode(message: PermissionToAdminRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    if (message.participantId !== 0) {
      writer.uint32(24).int32(message.participantId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionToAdminRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionToAdminRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.participantId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionToAdminRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      participantId: isSet(object.participantId) ? globalThis.Number(object.participantId) : 0,
    };
  },

  toJSON(message: PermissionToAdminRequest): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.participantId !== 0) {
      obj.participantId = Math.round(message.participantId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionToAdminRequest>, I>>(base?: I): PermissionToAdminRequest {
    return PermissionToAdminRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionToAdminRequest>, I>>(object: I): PermissionToAdminRequest {
    const message = createBasePermissionToAdminRequest();
    message.userId = object.userId ?? 0;
    message.chatId = object.chatId ?? "";
    message.participantId = object.participantId ?? 0;
    return message;
  },
};

function createBasePermissionToAdminResponse(): PermissionToAdminResponse {
  return { message: "", status: 0 };
}

export const PermissionToAdminResponse: MessageFns<PermissionToAdminResponse> = {
  encode(message: PermissionToAdminResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PermissionToAdminResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionToAdminResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PermissionToAdminResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: PermissionToAdminResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PermissionToAdminResponse>, I>>(base?: I): PermissionToAdminResponse {
    return PermissionToAdminResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PermissionToAdminResponse>, I>>(object: I): PermissionToAdminResponse {
    const message = createBasePermissionToAdminResponse();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseCreateNewChatRequest(): CreateNewChatRequest {
  return { chatName: "", chatType: "", userId: 0 };
}

export const CreateNewChatRequest: MessageFns<CreateNewChatRequest> = {
  encode(message: CreateNewChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatName !== "") {
      writer.uint32(10).string(message.chatName);
    }
    if (message.chatType !== "") {
      writer.uint32(18).string(message.chatType);
    }
    if (message.userId !== 0) {
      writer.uint32(24).int32(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNewChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNewChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNewChatRequest {
    return {
      chatName: isSet(object.chatName) ? globalThis.String(object.chatName) : "",
      chatType: isSet(object.chatType) ? globalThis.String(object.chatType) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: CreateNewChatRequest): unknown {
    const obj: any = {};
    if (message.chatName !== "") {
      obj.chatName = message.chatName;
    }
    if (message.chatType !== "") {
      obj.chatType = message.chatType;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNewChatRequest>, I>>(base?: I): CreateNewChatRequest {
    return CreateNewChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNewChatRequest>, I>>(object: I): CreateNewChatRequest {
    const message = createBaseCreateNewChatRequest();
    message.chatName = object.chatName ?? "";
    message.chatType = object.chatType ?? "";
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseCreateNewChatResponse(): CreateNewChatResponse {
  return { chatId: "" };
}

export const CreateNewChatResponse: MessageFns<CreateNewChatResponse> = {
  encode(message: CreateNewChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNewChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNewChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNewChatResponse {
    return { chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "" };
  },

  toJSON(message: CreateNewChatResponse): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNewChatResponse>, I>>(base?: I): CreateNewChatResponse {
    return CreateNewChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNewChatResponse>, I>>(object: I): CreateNewChatResponse {
    const message = createBaseCreateNewChatResponse();
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseGetChatByIdRequest(): GetChatByIdRequest {
  return { chatId: "" };
}

export const GetChatByIdRequest: MessageFns<GetChatByIdRequest> = {
  encode(message: GetChatByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChatByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChatByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChatByIdRequest {
    return { chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "" };
  },

  toJSON(message: GetChatByIdRequest): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChatByIdRequest>, I>>(base?: I): GetChatByIdRequest {
    return GetChatByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChatByIdRequest>, I>>(object: I): GetChatByIdRequest {
    const message = createBaseGetChatByIdRequest();
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseGetChatByIdResponse(): GetChatByIdResponse {
  return { chatData: undefined, notFound: undefined };
}

export const GetChatByIdResponse: MessageFns<GetChatByIdResponse> = {
  encode(message: GetChatByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatData !== undefined) {
      Chat.encode(message.chatData, writer.uint32(10).fork()).join();
    }
    if (message.notFound !== undefined) {
      ErrorResponse.encode(message.notFound, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChatByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChatByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatData = Chat.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notFound = ErrorResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChatByIdResponse {
    return {
      chatData: isSet(object.chatData) ? Chat.fromJSON(object.chatData) : undefined,
      notFound: isSet(object.notFound) ? ErrorResponse.fromJSON(object.notFound) : undefined,
    };
  },

  toJSON(message: GetChatByIdResponse): unknown {
    const obj: any = {};
    if (message.chatData !== undefined) {
      obj.chatData = Chat.toJSON(message.chatData);
    }
    if (message.notFound !== undefined) {
      obj.notFound = ErrorResponse.toJSON(message.notFound);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChatByIdResponse>, I>>(base?: I): GetChatByIdResponse {
    return GetChatByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChatByIdResponse>, I>>(object: I): GetChatByIdResponse {
    const message = createBaseGetChatByIdResponse();
    message.chatData = (object.chatData !== undefined && object.chatData !== null)
      ? Chat.fromPartial(object.chatData)
      : undefined;
    message.notFound = (object.notFound !== undefined && object.notFound !== null)
      ? ErrorResponse.fromPartial(object.notFound)
      : undefined;
    return message;
  },
};

function createBaseGetChatByChatNameRequest(): GetChatByChatNameRequest {
  return { chatName: "" };
}

export const GetChatByChatNameRequest: MessageFns<GetChatByChatNameRequest> = {
  encode(message: GetChatByChatNameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatName !== "") {
      writer.uint32(10).string(message.chatName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChatByChatNameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChatByChatNameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChatByChatNameRequest {
    return { chatName: isSet(object.chatName) ? globalThis.String(object.chatName) : "" };
  },

  toJSON(message: GetChatByChatNameRequest): unknown {
    const obj: any = {};
    if (message.chatName !== "") {
      obj.chatName = message.chatName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChatByChatNameRequest>, I>>(base?: I): GetChatByChatNameRequest {
    return GetChatByChatNameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChatByChatNameRequest>, I>>(object: I): GetChatByChatNameRequest {
    const message = createBaseGetChatByChatNameRequest();
    message.chatName = object.chatName ?? "";
    return message;
  },
};

function createBaseGetChatByChatNameResponse(): GetChatByChatNameResponse {
  return { chatData: [] };
}

export const GetChatByChatNameResponse: MessageFns<GetChatByChatNameResponse> = {
  encode(message: GetChatByChatNameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.chatData) {
      ChatIds.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChatByChatNameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChatByChatNameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatData.push(ChatIds.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChatByChatNameResponse {
    return {
      chatData: globalThis.Array.isArray(object?.chatData) ? object.chatData.map((e: any) => ChatIds.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetChatByChatNameResponse): unknown {
    const obj: any = {};
    if (message.chatData?.length) {
      obj.chatData = message.chatData.map((e) => ChatIds.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChatByChatNameResponse>, I>>(base?: I): GetChatByChatNameResponse {
    return GetChatByChatNameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChatByChatNameResponse>, I>>(object: I): GetChatByChatNameResponse {
    const message = createBaseGetChatByChatNameResponse();
    message.chatData = object.chatData?.map((e) => ChatIds.fromPartial(e)) || [];
    return message;
  },
};

function createBaseChatIds(): ChatIds {
  return { chatId: "", chatName: "" };
}

export const ChatIds: MessageFns<ChatIds> = {
  encode(message: ChatIds, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.chatName !== "") {
      writer.uint32(18).string(message.chatName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatIds {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatIds();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatIds {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      chatName: isSet(object.chatName) ? globalThis.String(object.chatName) : "",
    };
  },

  toJSON(message: ChatIds): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.chatName !== "") {
      obj.chatName = message.chatName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatIds>, I>>(base?: I): ChatIds {
    return ChatIds.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatIds>, I>>(object: I): ChatIds {
    const message = createBaseChatIds();
    message.chatId = object.chatId ?? "";
    message.chatName = object.chatName ?? "";
    return message;
  },
};

function createBaseUpdateChatByIdRequest(): UpdateChatByIdRequest {
  return { chatId: "", userId: 0, chatName: undefined, chatType: undefined, description: undefined };
}

export const UpdateChatByIdRequest: MessageFns<UpdateChatByIdRequest> = {
  encode(message: UpdateChatByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    if (message.chatName !== undefined) {
      writer.uint32(26).string(message.chatName);
    }
    if (message.chatType !== undefined) {
      writer.uint32(34).string(message.chatType);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChatByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChatByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chatName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chatType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChatByIdRequest {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      chatName: isSet(object.chatName) ? globalThis.String(object.chatName) : undefined,
      chatType: isSet(object.chatType) ? globalThis.String(object.chatType) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: UpdateChatByIdRequest): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.chatName !== undefined) {
      obj.chatName = message.chatName;
    }
    if (message.chatType !== undefined) {
      obj.chatType = message.chatType;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateChatByIdRequest>, I>>(base?: I): UpdateChatByIdRequest {
    return UpdateChatByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateChatByIdRequest>, I>>(object: I): UpdateChatByIdRequest {
    const message = createBaseUpdateChatByIdRequest();
    message.chatId = object.chatId ?? "";
    message.userId = object.userId ?? 0;
    message.chatName = object.chatName ?? undefined;
    message.chatType = object.chatType ?? undefined;
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseUpdateChatByIdResponse(): UpdateChatByIdResponse {
  return { response: undefined };
}

export const UpdateChatByIdResponse: MessageFns<UpdateChatByIdResponse> = {
  encode(message: UpdateChatByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      GenericResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateChatByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateChatByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = GenericResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateChatByIdResponse {
    return { response: isSet(object.response) ? GenericResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: UpdateChatByIdResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = GenericResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateChatByIdResponse>, I>>(base?: I): UpdateChatByIdResponse {
    return UpdateChatByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateChatByIdResponse>, I>>(object: I): UpdateChatByIdResponse {
    const message = createBaseUpdateChatByIdResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? GenericResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseDeleteChatByIdRequest(): DeleteChatByIdRequest {
  return { userId: 0, chatId: "" };
}

export const DeleteChatByIdRequest: MessageFns<DeleteChatByIdRequest> = {
  encode(message: DeleteChatByIdRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChatByIdRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChatByIdRequest {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
    };
  },

  toJSON(message: DeleteChatByIdRequest): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChatByIdRequest>, I>>(base?: I): DeleteChatByIdRequest {
    return DeleteChatByIdRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChatByIdRequest>, I>>(object: I): DeleteChatByIdRequest {
    const message = createBaseDeleteChatByIdRequest();
    message.userId = object.userId ?? 0;
    message.chatId = object.chatId ?? "";
    return message;
  },
};

function createBaseDeleteChatByIdResponse(): DeleteChatByIdResponse {
  return { response: undefined, info: undefined };
}

export const DeleteChatByIdResponse: MessageFns<DeleteChatByIdResponse> = {
  encode(message: DeleteChatByIdResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      DeleteChatByIdResponse_Response.encode(message.response, writer.uint32(10).fork()).join();
    }
    if (message.info !== undefined) {
      DeleteChatByIdResponse_Info.encode(message.info, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChatByIdResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = DeleteChatByIdResponse_Response.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.info = DeleteChatByIdResponse_Info.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChatByIdResponse {
    return {
      response: isSet(object.response) ? DeleteChatByIdResponse_Response.fromJSON(object.response) : undefined,
      info: isSet(object.info) ? DeleteChatByIdResponse_Info.fromJSON(object.info) : undefined,
    };
  },

  toJSON(message: DeleteChatByIdResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = DeleteChatByIdResponse_Response.toJSON(message.response);
    }
    if (message.info !== undefined) {
      obj.info = DeleteChatByIdResponse_Info.toJSON(message.info);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChatByIdResponse>, I>>(base?: I): DeleteChatByIdResponse {
    return DeleteChatByIdResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChatByIdResponse>, I>>(object: I): DeleteChatByIdResponse {
    const message = createBaseDeleteChatByIdResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? DeleteChatByIdResponse_Response.fromPartial(object.response)
      : undefined;
    message.info = (object.info !== undefined && object.info !== null)
      ? DeleteChatByIdResponse_Info.fromPartial(object.info)
      : undefined;
    return message;
  },
};

function createBaseDeleteChatByIdResponse_Response(): DeleteChatByIdResponse_Response {
  return { message: "", status: 0 };
}

export const DeleteChatByIdResponse_Response: MessageFns<DeleteChatByIdResponse_Response> = {
  encode(message: DeleteChatByIdResponse_Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChatByIdResponse_Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatByIdResponse_Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChatByIdResponse_Response {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: DeleteChatByIdResponse_Response): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChatByIdResponse_Response>, I>>(base?: I): DeleteChatByIdResponse_Response {
    return DeleteChatByIdResponse_Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChatByIdResponse_Response>, I>>(
    object: I,
  ): DeleteChatByIdResponse_Response {
    const message = createBaseDeleteChatByIdResponse_Response();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseDeleteChatByIdResponse_Info(): DeleteChatByIdResponse_Info {
  return { chatId: "", data: [] };
}

export const DeleteChatByIdResponse_Info: MessageFns<DeleteChatByIdResponse_Info> = {
  encode(message: DeleteChatByIdResponse_Info, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    writer.uint32(18).fork();
    for (const v of message.data) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteChatByIdResponse_Info {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteChatByIdResponse_Info();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.data.push(reader.int32());

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.data.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteChatByIdResponse_Info {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => globalThis.Number(e)) : [],
    };
  },

  toJSON(message: DeleteChatByIdResponse_Info): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteChatByIdResponse_Info>, I>>(base?: I): DeleteChatByIdResponse_Info {
    return DeleteChatByIdResponse_Info.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteChatByIdResponse_Info>, I>>(object: I): DeleteChatByIdResponse_Info {
    const message = createBaseDeleteChatByIdResponse_Info();
    message.chatId = object.chatId ?? "";
    message.data = object.data?.map((e) => e) || [];
    return message;
  },
};

function createBaseAddUserToChatRequest(): AddUserToChatRequest {
  return { chatId: "", participant: undefined };
}

export const AddUserToChatRequest: MessageFns<AddUserToChatRequest> = {
  encode(message: AddUserToChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.participant !== undefined) {
      ChatParticipant.encode(message.participant, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddUserToChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUserToChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participant = ChatParticipant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddUserToChatRequest {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      participant: isSet(object.participant) ? ChatParticipant.fromJSON(object.participant) : undefined,
    };
  },

  toJSON(message: AddUserToChatRequest): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.participant !== undefined) {
      obj.participant = ChatParticipant.toJSON(message.participant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUserToChatRequest>, I>>(base?: I): AddUserToChatRequest {
    return AddUserToChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddUserToChatRequest>, I>>(object: I): AddUserToChatRequest {
    const message = createBaseAddUserToChatRequest();
    message.chatId = object.chatId ?? "";
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? ChatParticipant.fromPartial(object.participant)
      : undefined;
    return message;
  },
};

function createBaseAddUserToChatResponse(): AddUserToChatResponse {
  return { response: undefined };
}

export const AddUserToChatResponse: MessageFns<AddUserToChatResponse> = {
  encode(message: AddUserToChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      GenericResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddUserToChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUserToChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = GenericResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddUserToChatResponse {
    return { response: isSet(object.response) ? GenericResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: AddUserToChatResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = GenericResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUserToChatResponse>, I>>(base?: I): AddUserToChatResponse {
    return AddUserToChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddUserToChatResponse>, I>>(object: I): AddUserToChatResponse {
    const message = createBaseAddUserToChatResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? GenericResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseRemoveUserFromChatRequest(): RemoveUserFromChatRequest {
  return { chatId: "", userId: 0 };
}

export const RemoveUserFromChatRequest: MessageFns<RemoveUserFromChatRequest> = {
  encode(message: RemoveUserFromChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveUserFromChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserFromChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserFromChatRequest {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: RemoveUserFromChatRequest): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserFromChatRequest>, I>>(base?: I): RemoveUserFromChatRequest {
    return RemoveUserFromChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserFromChatRequest>, I>>(object: I): RemoveUserFromChatRequest {
    const message = createBaseRemoveUserFromChatRequest();
    message.chatId = object.chatId ?? "";
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseRemoveUserFromChatResponse(): RemoveUserFromChatResponse {
  return { response: undefined };
}

export const RemoveUserFromChatResponse: MessageFns<RemoveUserFromChatResponse> = {
  encode(message: RemoveUserFromChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      GenericResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveUserFromChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserFromChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = GenericResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserFromChatResponse {
    return { response: isSet(object.response) ? GenericResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: RemoveUserFromChatResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = GenericResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserFromChatResponse>, I>>(base?: I): RemoveUserFromChatResponse {
    return RemoveUserFromChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserFromChatResponse>, I>>(object: I): RemoveUserFromChatResponse {
    const message = createBaseRemoveUserFromChatResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? GenericResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseLoadToChatRequest(): LoadToChatRequest {
  return { chatId: "", userId: 0 };
}

export const LoadToChatRequest: MessageFns<LoadToChatRequest> = {
  encode(message: LoadToChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadToChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadToChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadToChatRequest {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: LoadToChatRequest): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadToChatRequest>, I>>(base?: I): LoadToChatRequest {
    return LoadToChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadToChatRequest>, I>>(object: I): LoadToChatRequest {
    const message = createBaseLoadToChatRequest();
    message.chatId = object.chatId ?? "";
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseLoadToChatResponse(): LoadToChatResponse {
  return { response: undefined };
}

export const LoadToChatResponse: MessageFns<LoadToChatResponse> = {
  encode(message: LoadToChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      GenericResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoadToChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoadToChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = GenericResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoadToChatResponse {
    return { response: isSet(object.response) ? GenericResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: LoadToChatResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = GenericResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoadToChatResponse>, I>>(base?: I): LoadToChatResponse {
    return LoadToChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoadToChatResponse>, I>>(object: I): LoadToChatResponse {
    const message = createBaseLoadToChatResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? GenericResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseLeaveFromChatRequest(): LeaveFromChatRequest {
  return { chatId: "", userId: 0 };
}

export const LeaveFromChatRequest: MessageFns<LeaveFromChatRequest> = {
  encode(message: LeaveFromChatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.userId !== 0) {
      writer.uint32(16).int32(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveFromChatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveFromChatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveFromChatRequest {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
    };
  },

  toJSON(message: LeaveFromChatRequest): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveFromChatRequest>, I>>(base?: I): LeaveFromChatRequest {
    return LeaveFromChatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveFromChatRequest>, I>>(object: I): LeaveFromChatRequest {
    const message = createBaseLeaveFromChatRequest();
    message.chatId = object.chatId ?? "";
    message.userId = object.userId ?? 0;
    return message;
  },
};

function createBaseLeaveFromChatResponse(): LeaveFromChatResponse {
  return { response: undefined };
}

export const LeaveFromChatResponse: MessageFns<LeaveFromChatResponse> = {
  encode(message: LeaveFromChatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.response !== undefined) {
      GenericResponse.encode(message.response, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveFromChatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveFromChatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.response = GenericResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveFromChatResponse {
    return { response: isSet(object.response) ? GenericResponse.fromJSON(object.response) : undefined };
  },

  toJSON(message: LeaveFromChatResponse): unknown {
    const obj: any = {};
    if (message.response !== undefined) {
      obj.response = GenericResponse.toJSON(message.response);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LeaveFromChatResponse>, I>>(base?: I): LeaveFromChatResponse {
    return LeaveFromChatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LeaveFromChatResponse>, I>>(object: I): LeaveFromChatResponse {
    const message = createBaseLeaveFromChatResponse();
    message.response = (object.response !== undefined && object.response !== null)
      ? GenericResponse.fromPartial(object.response)
      : undefined;
    return message;
  },
};

function createBaseChat(): Chat {
  return {
    chatId: "",
    chatName: "",
    chatType: "",
    lastMessage: undefined,
    participants: [],
    messages: [],
    createdAt: undefined,
  };
}

export const Chat: MessageFns<Chat> = {
  encode(message: Chat, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.chatId !== "") {
      writer.uint32(10).string(message.chatId);
    }
    if (message.chatName !== "") {
      writer.uint32(18).string(message.chatName);
    }
    if (message.chatType !== "") {
      writer.uint32(26).string(message.chatType);
    }
    if (message.lastMessage !== undefined) {
      LastMessage.encode(message.lastMessage, writer.uint32(34).fork()).join();
    }
    for (const v of message.participants) {
      ChatParticipant.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chat {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.chatId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.chatName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.chatType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastMessage = LastMessage.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.participants.push(ChatParticipant.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chat {
    return {
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      chatName: isSet(object.chatName) ? globalThis.String(object.chatName) : "",
      chatType: isSet(object.chatType) ? globalThis.String(object.chatType) : "",
      lastMessage: isSet(object.lastMessage) ? LastMessage.fromJSON(object.lastMessage) : undefined,
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => ChatParticipant.fromJSON(e))
        : [],
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
    };
  },

  toJSON(message: Chat): unknown {
    const obj: any = {};
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.chatName !== "") {
      obj.chatName = message.chatName;
    }
    if (message.chatType !== "") {
      obj.chatType = message.chatType;
    }
    if (message.lastMessage !== undefined) {
      obj.lastMessage = LastMessage.toJSON(message.lastMessage);
    }
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => ChatParticipant.toJSON(e));
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chat>, I>>(base?: I): Chat {
    return Chat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chat>, I>>(object: I): Chat {
    const message = createBaseChat();
    message.chatId = object.chatId ?? "";
    message.chatName = object.chatName ?? "";
    message.chatType = object.chatType ?? "";
    message.lastMessage = (object.lastMessage !== undefined && object.lastMessage !== null)
      ? LastMessage.fromPartial(object.lastMessage)
      : undefined;
    message.participants = object.participants?.map((e) => ChatParticipant.fromPartial(e)) || [];
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    return message;
  },
};

function createBaseLastMessage(): LastMessage {
  return { messageId: "", senderId: 0, preview: "" };
}

export const LastMessage: MessageFns<LastMessage> = {
  encode(message: LastMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.senderId !== 0) {
      writer.uint32(16).int32(message.senderId);
    }
    if (message.preview !== "") {
      writer.uint32(26).string(message.preview);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.senderId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.preview = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LastMessage {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      senderId: isSet(object.senderId) ? globalThis.Number(object.senderId) : 0,
      preview: isSet(object.preview) ? globalThis.String(object.preview) : "",
    };
  },

  toJSON(message: LastMessage): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.senderId !== 0) {
      obj.senderId = Math.round(message.senderId);
    }
    if (message.preview !== "") {
      obj.preview = message.preview;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LastMessage>, I>>(base?: I): LastMessage {
    return LastMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LastMessage>, I>>(object: I): LastMessage {
    const message = createBaseLastMessage();
    message.messageId = object.messageId ?? "";
    message.senderId = object.senderId ?? 0;
    message.preview = object.preview ?? "";
    return message;
  },
};

function createBaseChatParticipant(): ChatParticipant {
  return { userId: 0, role: "" };
}

export const ChatParticipant: MessageFns<ChatParticipant> = {
  encode(message: ChatParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== 0) {
      writer.uint32(8).int32(message.userId);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.userId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatParticipant {
    return {
      userId: isSet(object.userId) ? globalThis.Number(object.userId) : 0,
      role: isSet(object.role) ? globalThis.String(object.role) : "",
    };
  },

  toJSON(message: ChatParticipant): unknown {
    const obj: any = {};
    if (message.userId !== 0) {
      obj.userId = Math.round(message.userId);
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatParticipant>, I>>(base?: I): ChatParticipant {
    return ChatParticipant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatParticipant>, I>>(object: I): ChatParticipant {
    const message = createBaseChatParticipant();
    message.userId = object.userId ?? 0;
    message.role = object.role ?? "";
    return message;
  },
};

function createBaseMessage(): Message {
  return { messageId: "", senderId: 0, text: "", timestamp: undefined };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    if (message.senderId !== 0) {
      writer.uint32(16).int32(message.senderId);
    }
    if (message.text !== "") {
      writer.uint32(26).string(message.text);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.senderId = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "",
      senderId: isSet(object.senderId) ? globalThis.Number(object.senderId) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    if (message.senderId !== 0) {
      obj.senderId = Math.round(message.senderId);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.messageId = object.messageId ?? "";
    message.senderId = object.senderId ?? 0;
    message.text = object.text ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseErrorResponse(): ErrorResponse {
  return { message: "", status: 0 };
}

export const ErrorResponse: MessageFns<ErrorResponse> = {
  encode(message: ErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ErrorResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: ErrorResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorResponse>, I>>(base?: I): ErrorResponse {
    return ErrorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorResponse>, I>>(object: I): ErrorResponse {
    const message = createBaseErrorResponse();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseGenericResponse(): GenericResponse {
  return { message: "", status: 0 };
}

export const GenericResponse: MessageFns<GenericResponse> = {
  encode(message: GenericResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenericResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenericResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenericResponse {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      status: isSet(object.status) ? globalThis.Number(object.status) : 0,
    };
  },

  toJSON(message: GenericResponse): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.status !== 0) {
      obj.status = Math.round(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenericResponse>, I>>(base?: I): GenericResponse {
    return GenericResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenericResponse>, I>>(object: I): GenericResponse {
    const message = createBaseGenericResponse();
    message.message = object.message ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

/**   */
export interface ChatService {
  CreateNewChat(request: CreateNewChatRequest): Promise<CreateNewChatResponse>;
  GetChatById(request: GetChatByIdRequest): Promise<GetChatByIdResponse>;
  GetChatByChatName(request: GetChatByChatNameRequest): Promise<GetChatByChatNameResponse>;
  UpdateChatById(request: UpdateChatByIdRequest): Promise<UpdateChatByIdResponse>;
  DeleteChatById(request: DeleteChatByIdRequest): Promise<DeleteChatByIdResponse>;
  AddUserToChat(request: AddUserToChatRequest): Promise<AddUserToChatResponse>;
  LoadToChat(request: LoadToChatRequest): Promise<LoadToChatResponse>;
  LeaveFromChat(request: LeaveFromChatRequest): Promise<LeaveFromChatResponse>;
  PermissionToAdmin(request: PermissionToAdminRequest): Promise<PermissionToAdminResponse>;
  PermissionToMember(request: PermissionToMemberRequest): Promise<PermissionToMemberResponse>;
  RemoveUserFromChat(request: RemoveUserFromChatRequest): Promise<RemoveUserFromChatResponse>;
  KickUserFromChat(request: KickUserFromChatRequest): Promise<KickUserFromChatResponse>;
  GetTokenAndAddToChat(request: GetTokenAndAddToChatRequest): Promise<GetTokenAndAddToChatResponse>;
}

export const ChatServiceServiceName = "chat.ChatService";
export class ChatServiceClientImpl implements ChatService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ChatServiceServiceName;
    this.rpc = rpc;
    this.CreateNewChat = this.CreateNewChat.bind(this);
    this.GetChatById = this.GetChatById.bind(this);
    this.GetChatByChatName = this.GetChatByChatName.bind(this);
    this.UpdateChatById = this.UpdateChatById.bind(this);
    this.DeleteChatById = this.DeleteChatById.bind(this);
    this.AddUserToChat = this.AddUserToChat.bind(this);
    this.LoadToChat = this.LoadToChat.bind(this);
    this.LeaveFromChat = this.LeaveFromChat.bind(this);
    this.PermissionToAdmin = this.PermissionToAdmin.bind(this);
    this.PermissionToMember = this.PermissionToMember.bind(this);
    this.RemoveUserFromChat = this.RemoveUserFromChat.bind(this);
    this.KickUserFromChat = this.KickUserFromChat.bind(this);
    this.GetTokenAndAddToChat = this.GetTokenAndAddToChat.bind(this);
  }
  CreateNewChat(request: CreateNewChatRequest): Promise<CreateNewChatResponse> {
    const data = CreateNewChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateNewChat", data);
    return promise.then((data) => CreateNewChatResponse.decode(new BinaryReader(data)));
  }

  GetChatById(request: GetChatByIdRequest): Promise<GetChatByIdResponse> {
    const data = GetChatByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChatById", data);
    return promise.then((data) => GetChatByIdResponse.decode(new BinaryReader(data)));
  }

  GetChatByChatName(request: GetChatByChatNameRequest): Promise<GetChatByChatNameResponse> {
    const data = GetChatByChatNameRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetChatByChatName", data);
    return promise.then((data) => GetChatByChatNameResponse.decode(new BinaryReader(data)));
  }

  UpdateChatById(request: UpdateChatByIdRequest): Promise<UpdateChatByIdResponse> {
    const data = UpdateChatByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateChatById", data);
    return promise.then((data) => UpdateChatByIdResponse.decode(new BinaryReader(data)));
  }

  DeleteChatById(request: DeleteChatByIdRequest): Promise<DeleteChatByIdResponse> {
    const data = DeleteChatByIdRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteChatById", data);
    return promise.then((data) => DeleteChatByIdResponse.decode(new BinaryReader(data)));
  }

  AddUserToChat(request: AddUserToChatRequest): Promise<AddUserToChatResponse> {
    const data = AddUserToChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddUserToChat", data);
    return promise.then((data) => AddUserToChatResponse.decode(new BinaryReader(data)));
  }

  LoadToChat(request: LoadToChatRequest): Promise<LoadToChatResponse> {
    const data = LoadToChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LoadToChat", data);
    return promise.then((data) => LoadToChatResponse.decode(new BinaryReader(data)));
  }

  LeaveFromChat(request: LeaveFromChatRequest): Promise<LeaveFromChatResponse> {
    const data = LeaveFromChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "LeaveFromChat", data);
    return promise.then((data) => LeaveFromChatResponse.decode(new BinaryReader(data)));
  }

  PermissionToAdmin(request: PermissionToAdminRequest): Promise<PermissionToAdminResponse> {
    const data = PermissionToAdminRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionToAdmin", data);
    return promise.then((data) => PermissionToAdminResponse.decode(new BinaryReader(data)));
  }

  PermissionToMember(request: PermissionToMemberRequest): Promise<PermissionToMemberResponse> {
    const data = PermissionToMemberRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionToMember", data);
    return promise.then((data) => PermissionToMemberResponse.decode(new BinaryReader(data)));
  }

  RemoveUserFromChat(request: RemoveUserFromChatRequest): Promise<RemoveUserFromChatResponse> {
    const data = RemoveUserFromChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RemoveUserFromChat", data);
    return promise.then((data) => RemoveUserFromChatResponse.decode(new BinaryReader(data)));
  }

  KickUserFromChat(request: KickUserFromChatRequest): Promise<KickUserFromChatResponse> {
    const data = KickUserFromChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "KickUserFromChat", data);
    return promise.then((data) => KickUserFromChatResponse.decode(new BinaryReader(data)));
  }

  GetTokenAndAddToChat(request: GetTokenAndAddToChatRequest): Promise<GetTokenAndAddToChatResponse> {
    const data = GetTokenAndAddToChatRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetTokenAndAddToChat", data);
    return promise.then((data) => GetTokenAndAddToChatResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
